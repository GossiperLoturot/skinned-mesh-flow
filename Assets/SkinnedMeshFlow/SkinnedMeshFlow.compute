#pragma kernel CSMain

struct StandardVertex
{
    float3 position;
    float3 normal;
    float4 tangent;
};

float3x3 inverse(float3x3 m)
{
    float3x3 n;
    n._11 = m._22 * m._33 - m._23 * m._32;
    n._12 = m._13 * m._32 - m._12 * m._33;
    n._13 = m._12 * m._23 - m._13 * m._22;
    n._21 = m._23 * m._31 - m._21 * m._33;
    n._22 = m._11 * m._33 - m._13 * m._31;
    n._23 = m._13 * m._21 - m._11 * m._23;
    n._31 = m._21 * m._32 - m._22 * m._31;
    n._32 = m._12 * m._31 - m._11 * m._32;
    n._33 = m._11 * m._22 - m._12 * m._21;
    return rcp(determinant(m)) * n;
}

void jacobiRotate(inout float3x3 A, inout float3x3 X, int p, int q)
{
    if (abs(A[p][q]) < 1e-6)
    {
        A[p][q] = A[q][p] = 0;
        return;
    }

    // compute rotation angle
    float tau = (A[q][q] - A[p][p]) / (2 * A[p][q]);

    // compute tangent and cosine, sine
    float t = 1 / (abs(tau) + sqrt(1 + tau * tau));
    if (tau < 0) t = -t;
    float c = 1 / sqrt(1 + t * t);
    float s = t * c;

    float A_pp = A[p][p];
    float A_qq = A[q][q];
    float A_pq = A[p][q];
    
    int k = 3 - p - q; 
    float A_pk = A[p][k];
    float A_qk = A[q][k];

    A[p][p] = A_pp - t * A_pq;
    A[q][q] = A_qq + t * A_pq;
    A[p][q] = A[q][p] = 0;
    A[p][k] = A[k][p] = c * A_pk - s * A_qk;
    A[q][k] = A[k][q] = s * A_pk + c * A_qk;

    for (int i = 0; i < 3; i++)
    {
        float X_ip = X[i][p];
        float X_iq = X[i][q];
        X[i][p] = c * X_ip - s * X_iq;
        X[i][q] = s * X_ip + c * X_iq;
    }
}

void eigenDecomp(in float3x3 M, out float3 eigenValues, out float3x3 eigenVectors)
{
    const int MAX_ITERATIONS = 32;

    eigenVectors = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    float3x3 A = M;

    [loop]
    for (int n = 0; n < MAX_ITERATIONS; n++)
    {
        jacobiRotate(A, eigenVectors, 0, 1);
        jacobiRotate(A, eigenVectors, 1, 2);
        jacobiRotate(A, eigenVectors, 2, 0);
    }

    eigenVectors = transpose(eigenVectors);

    eigenValues = float3(A._11, A._22, A._33);
}

int VertexCount;
float4x4 AdjustMatrix;

RWStructuredBuffer<StandardVertex> SrcVertexBuffer;
RWStructuredBuffer<StandardVertex> DstVertexBuffer;
RWStructuredBuffer<int2> AdjacentBuffer;
RWStructuredBuffer<int2> AddressBuffer;
RWStructuredBuffer<float4x4> EigenpairBuffer;

[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int idx0 = id.x;

    if (idx0 >= VertexCount) return;

    StandardVertex srcVertex = SrcVertexBuffer[idx0];
    StandardVertex dstVertex = DstVertexBuffer[idx0];

    float3 src0 = srcVertex.position;
    float3 dst0 = mul(AdjustMatrix, float4(dstVertex.position, 1)).xyz;

    float3x3 srcA = 0;
    float3x3 dstA = 0;
    float3x3 F = 0;
    float F_norm = 0;

    int2 address = AddressBuffer[idx0];

    [loop]
    for (int i = address.x; i < address.y; i++)
    {
        int idx1 = AdjacentBuffer[i].x;
        int idx2 = AdjacentBuffer[i].y;

        srcA[0] = SrcVertexBuffer[idx1].position - src0;
        srcA[1] = SrcVertexBuffer[idx2].position - src0;
        srcA[2] = normalize(cross(srcA[0], srcA[1]));
        srcA = transpose(srcA);

        dstA[0] = mul(AdjustMatrix, float4(DstVertexBuffer[idx1].position, 1)).xyz - dst0;
        dstA[1] = mul(AdjustMatrix, float4(DstVertexBuffer[idx2].position, 1)).xyz - dst0;
        dstA[2] = normalize(cross(dstA[0], dstA[1]));
        dstA = transpose(dstA);

        F += mul(dstA, inverse(srcA));
        F_norm += 1.0;
    }
    F = F / F_norm;

    float3x3 C = mul(transpose(F), F);
    float3x3 E = 0.5 * (C - float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1));

    float3x3 srcTBN = 0;
    srcTBN[2] = normalize(srcVertex.normal);
    srcTBN[0] = normalize(srcVertex.tangent.xyz);
    srcTBN[1] = cross(srcTBN[2], srcTBN[0]) * srcVertex.tangent.w;
    srcTBN = transpose(srcTBN);
    float3x3 dstTBN = 0;
    dstTBN[2] = normalize(dstVertex.normal);
    dstTBN[0] = normalize(dstVertex.tangent.xyz);
    dstTBN[1] = cross(dstTBN[2], dstTBN[0]) * dstVertex.tangent.w;
    dstTBN = transpose(dstTBN);

    E = mul(mul(dstTBN, inverse(srcTBN)), E);

    float4x4 eigenpair = 0;
    eigenpair[0].xyz = mul(E, float3(1, 0, 0));
    eigenpair[1].xyz = mul(E, float3(0, 1, 0));
    eigenpair[2].xyz = mul(E, float3(0, 0, 1));
    eigenpair[3].xyz = float3(1, 1, 1);
    EigenpairBuffer[idx0] = eigenpair;
}
