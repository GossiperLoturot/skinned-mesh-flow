#pragma kernel CSMain

struct StandardVertex
{
    float3 position;
    float3 normal;
    float4 tangent;
};

float3x3 inverse(float3x3 m)
{
    float3x3 n;
    n._11 = m._22 * m._33 - m._23 * m._32;
    n._12 = m._13 * m._32 - m._12 * m._33;
    n._13 = m._12 * m._23 - m._13 * m._22;
    n._21 = m._23 * m._31 - m._21 * m._33;
    n._22 = m._11 * m._33 - m._13 * m._31;
    n._23 = m._13 * m._21 - m._11 * m._23;
    n._31 = m._21 * m._32 - m._22 * m._31;
    n._32 = m._12 * m._31 - m._11 * m._32;
    n._33 = m._11 * m._22 - m._12 * m._21;
    return rcp(determinant(m)) * n;
}

void jacobiRotate(inout float3x3 A, inout float3x3 X, int p, int q)
{
    if (abs(A[p][q]) < 1e-6)
    {
        A[p][q] = A[q][p] = 0;
        return;
    }

    // compute rotation angle
    float tau = (A[q][q] - A[p][p]) / (2 * A[p][q]);

    // compute tangent and cosine, sine
    float t = 1 / (abs(tau) + sqrt(1 + tau * tau));
    if (tau < 0) t = -t;
    float c = 1 / sqrt(1 + t * t);
    float s = t * c;

    float A_pp = A[p][p];
    float A_qq = A[q][q];
    float A_pq = A[p][q];
    
    int k = 3 - p - q; 
    float A_pk = A[p][k];
    float A_qk = A[q][k];

    A[p][p] = A_pp - t * A_pq;
    A[q][q] = A_qq + t * A_pq;
    A[p][q] = A[q][p] = 0;
    A[p][k] = A[k][p] = c * A_pk - s * A_qk;
    A[q][k] = A[k][q] = s * A_pk + c * A_qk;

    for (int i = 0; i < 3; i++)
    {
        float X_ip = X[i][p];
        float X_iq = X[i][q];
        X[i][p] = c * X_ip - s * X_iq;
        X[i][q] = s * X_ip + c * X_iq;
    }
}

void eigenDecomp(in float3x3 M, out float3 eigenValues, out float3x3 eigenVectors)
{
    const int MAX_ITERATIONS = 32;

    eigenVectors = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    float3x3 A = M;

    [loop]
    for (int n = 0; n < MAX_ITERATIONS; n++)
    {
        jacobiRotate(A, eigenVectors, 0, 1);
        jacobiRotate(A, eigenVectors, 1, 2);
        jacobiRotate(A, eigenVectors, 2, 0);
    }

    eigenVectors = transpose(eigenVectors);

    eigenValues = float3(A._11, A._22, A._33);
}

int VertexCount;
float4x4 AdjustMatrix;

RWStructuredBuffer<StandardVertex> SrcVertexBuffer;
RWStructuredBuffer<StandardVertex> DstVertexBuffer;
RWStructuredBuffer<int2> AdjacentBuffer;
RWStructuredBuffer<int2> AddressBuffer;
RWStructuredBuffer<float3> StrainBuffer;
RWStructuredBuffer<float4x4> EigenpairBuffer;

[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int idx0 = id.x;

    if (idx0 >= VertexCount) return;

    float3 srcPosition = SrcVertexBuffer[idx0].position;
    float3 dstPosition = DstVertexBuffer[idx0].position;

    // Create World to TBN matrix on source mesh
    StandardVertex srcVertex = SrcVertexBuffer[idx0];
    float3x3 srcTBN = 0;
    srcTBN[0] = srcVertex.tangent.xyz;
    srcTBN[1] = cross(srcVertex.normal, srcVertex.tangent.xyz) * srcVertex.tangent.w;
    srcTBN[2] = srcVertex.normal;
    srcTBN = transpose(srcTBN);
    srcTBN = inverse(srcTBN);

    // Create World to TBN matrix on destination mesh
    StandardVertex dstVertex = DstVertexBuffer[idx0];
    float3x3 dstTBN = 0;
    dstTBN[2] = dstVertex.normal;
    dstTBN[0] = dstVertex.tangent.xyz;
    dstTBN[1] = cross(dstVertex.normal, dstVertex.tangent.xyz) * dstVertex.tangent.w;
    dstTBN = transpose(dstTBN);
    dstTBN = inverse(dstTBN);

    float3x3 srcA = 0;
    float3x3 dstA = 0;
    float3x3 F = 0;
    float F_area = 0;

    int2 address = AddressBuffer[idx0];

    [loop]
    for (int i = address.x; i < address.y; i++)
    {
        int idx1 = AdjacentBuffer[i].x;
        int idx2 = AdjacentBuffer[i].y;

        float3 srcPosition1 = SrcVertexBuffer[idx1].position;
        float3 srcPosition2 = SrcVertexBuffer[idx2].position;
        srcA[0] = srcPosition1 - srcPosition;
        srcA[1] = srcPosition2 - srcPosition;
        srcA[2] = normalize(cross(srcA[0], srcA[1]));
        srcA = transpose(srcA);
        srcA = mul(srcTBN, srcA);

        float3 dstPosition1 = DstVertexBuffer[idx1].position;
        float3 dstPosition2 = DstVertexBuffer[idx2].position;
        dstA[0] = dstPosition1 - dstPosition;
        dstA[1] = dstPosition2 - dstPosition;
        dstA[2] = normalize(cross(dstA[0], dstA[1]));
        dstA = transpose(dstA);
        dstA = mul(dstTBN, dstA);

        float area = length(cross(srcPosition1 - srcPosition, srcPosition2 - srcPosition)) * 0.5;
        F += area * mul(dstA, inverse(srcA));
        F_area += area;
    }
    F = F / F_area;

    float3x3 C = mul(transpose(F), F);
    float3x3 E = 0.5 * (C - float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1));

    float3 eigenValues;
    float3x3 eigenVectors;
    eigenDecomp(E, eigenValues, eigenVectors);

    float3 l = abs(eigenValues);
    if (l.x >= l.y && l.x >= l.z) StrainBuffer[idx0] = float3(eigenVectors[0].xy, eigenValues.x);
    if (l.y >= l.z && l.y >= l.x) StrainBuffer[idx0] = float3(eigenVectors[1].xy, eigenValues.y);
    if (l.z >= l.x && l.z >= l.y) StrainBuffer[idx0] = float3(eigenVectors[2].xy, eigenValues.z);

    float4x4 eigenpair = 0;
    eigenpair[0].xyz = eigenVectors[0];
    eigenpair[1].xyz = eigenVectors[1];
    eigenpair[2].xyz = eigenVectors[2];
    eigenpair[3].xyz = eigenValues;
    EigenpairBuffer[idx0] = eigenpair;
}
