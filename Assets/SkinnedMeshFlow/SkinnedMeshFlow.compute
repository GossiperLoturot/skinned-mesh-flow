#pragma kernel CSMain

struct StandardVertex
{
    float3 position;
    float3 normal;
    float4 tangent;
};

float3x3 inverse(float3x3 m)
{
    float3x3 n;
    n._11 = m._22 * m._33 - m._23 * m._32;
    n._12 = m._13 * m._32 - m._12 * m._33;
    n._13 = m._12 * m._23 - m._13 * m._22;
    n._21 = m._23 * m._31 - m._21 * m._33;
    n._22 = m._11 * m._33 - m._13 * m._31;
    n._23 = m._13 * m._21 - m._11 * m._23;
    n._31 = m._21 * m._32 - m._22 * m._31;
    n._32 = m._12 * m._31 - m._11 * m._32;
    n._33 = m._11 * m._22 - m._12 * m._21;
    return rcp(determinant(m)) * n;
}

void jacobiRotate(inout float3x3 A, inout float3x3 X, int p, int q)
{
    if (abs(A[p][q]) < 1e-8)
    {
        A[p][q] = A[q][p] = 0;
        return;
    }

    // compute rotation angle
    float tau = (A[q][q] - A[p][p]) / (2 * A[p][q]);

    // compute tangent and cosine, sine
    float t = 1 / (abs(tau) + sqrt(1 + tau * tau));
    if (tau < 0) t = -t;
    float c = 1 / sqrt(1 + t * t);
    float s = t * c;

    float A_pp = A[p][p];
    float A_qq = A[q][q];
    float A_pq = A[p][q];
    
    int k = 3 - p - q; 
    float A_pk = A[p][k];
    float A_qk = A[q][k];

    A[p][p] = A_pp - t * A_pq;
    A[q][q] = A_qq + t * A_pq;
    A[p][q] = A[q][p] = 0;
    A[p][k] = A[k][p] = c * A_pk - s * A_qk;
    A[q][k] = A[k][q] = s * A_pk + c * A_qk;

    for (int i = 0; i < 3; i++)
    {
        float X_ip = X[i][p];
        float X_iq = X[i][q];
        X[i][p] = c * X_ip - s * X_iq;
        X[i][q] = s * X_ip + c * X_iq;
    }
}

void eigenDecomp(in float3x3 M, out float3 eigenValues, out float3x3 eigenVectors)
{
    const int MAX_ITERATIONS = 32;

    eigenVectors = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    float3x3 A = M;

    [loop]
    for (int n = 0; n < MAX_ITERATIONS; n++)
    {
        jacobiRotate(A, eigenVectors, 0, 1);
        jacobiRotate(A, eigenVectors, 1, 2);
        jacobiRotate(A, eigenVectors, 2, 0);
    }

    eigenValues = float3(A._11, A._22, A._33);
}

int VertexCount;
float4x4 AdjustMatrix;

RWStructuredBuffer<StandardVertex> SrcVertexBuffer;
RWStructuredBuffer<StandardVertex> DstVertexBuffer;
RWStructuredBuffer<int> AdjacentBuffer;
RWStructuredBuffer<int2> AddressBuffer;
RWStructuredBuffer<float4> EigenBuffer;

[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int idx0 = id.x;

    if (idx0 >= VertexCount) return;

    float3 src0 = SrcVertexBuffer[idx0].position;
    float3 dst0 = mul(AdjustMatrix, float4(DstVertexBuffer[idx0].position, 1)).xyz;

    float A_[6] = { 0, 0, 0, 0, 0, 0 };
    float3x3 B = 0;

    int2 address = AddressBuffer[idx0];

    [loop]
    for (int i = address.x; i < address.y; i++)
    {
        int idx1 = AdjacentBuffer[i];

        float3 src1 = SrcVertexBuffer[idx1].position;
        float3 dst1 = mul(AdjustMatrix, float4(DstVertexBuffer[idx1].position, 1)).xyz;

        float3 e_ref = src1 - src0;
        float3 e_def = dst1 - dst0;

        A_[0] += e_ref.x * e_ref.x;
        A_[1] += e_ref.y * e_ref.y;
        A_[2] += e_ref.z * e_ref.z;
        A_[3] += e_ref.x * e_ref.y;
        A_[4] += e_ref.y * e_ref.z;
        A_[5] += e_ref.z * e_ref.x;

        B[0] += e_def * e_ref.x;
        B[1] += e_def * e_ref.y;
        B[2] += e_def * e_ref.z;
    }

    float3x3 A = float3x3(
        A_[0], A_[3], A_[5],
        A_[3], A_[1], A_[4],
        A_[5], A_[4], A_[2]
    );

    A._11 += 1e-8;
    A._22 += 1e-8;
    A._33 += 1e-8;

    float3x3 F = mul(inverse(A), B);
    float3x3 E = (transpose(F) * F - float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1)) * 0.5;

    float3 eigenValues;
    float3x3 eigenVectors;
    eigenDecomp(E, eigenValues, eigenVectors);
    
    float l0 = eigenValues.x;
    float l1 = eigenValues.y;
    float l2 = eigenValues.z;
    if (l0 >= l1 && l0 >= l2) EigenBuffer[idx0] = float4(eigenVectors[0], l0);
    else if (l1 >= l2 && l1 >= l0) EigenBuffer[idx0] = float4(eigenVectors[1], l1);
    else if (l2 >= l0 && l2 >= l1) EigenBuffer[idx0] = float4(eigenVectors[2], l2);
}
